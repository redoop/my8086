# MyCPU8086 架构设计文档

## 概述

MyCPU8086 是一个渐进式开发的 8086 简化 CPU 实现。当前有三个版本文件，代表了开发的不同阶段。

## 版本演进

### v0.1.0 - 初始版本 (CPU8086.scala)
- **目的**: 概念验证
- **指令**: 3 条
- **状态**: 已被 MVP 版本取代

### v0.2.0 - Milestone 1 MVP (MyCPU8086_MVP.scala)
- **目的**: 最小可用系统
- **指令**: 15 条
- **状态**: 已被 M2 版本取代

### v0.3.0 - Milestone 2 (MyCPU8086_M2.scala) ⭐ 当前推荐
- **目的**: 基础功能完整
- **指令**: 45 条
- **状态**: 当前最新版本

## 架构分析

### 这是一个芯片还是三个芯片？

**答案**: 这是**一个芯片的三个演进版本**

**原因**:
1. 它们实现的是同一个 CPU 架构（8086）
2. 指令集完全向后兼容
3. 寄存器组织相同
4. 内存接口一致
5. 只是功能逐步增强

### 类比

```
就像 Intel 的产品线:
- 8086 (基础版)
- 8086-2 (增强版)  
- 8086-3 (完整版)

但它们本质上是同一个架构的不同实现
```

## 整合方案

### 推荐方案：使用 M2 作为统一实现

**理由**:
1. M2 包含所有 MVP 和初始版本的功能
2. 状态机最完整（7 状态）
3. 指令集最全（45 条）
4. 向后兼容所有旧代码

### 架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    MyCPU8086_M2 (统一芯片)                   │
├─────────────────────────────────────────────────────────────┤
│  寄存器组                                                    │
│  ├── 通用寄存器: AX, BX, CX, DX                            │
│  ├── 指针寄存器: SP, BP, SI, DI                            │
│  ├── 段寄存器: CS, DS, SS, ES                              │
│  ├── 指令指针: IP                                           │
│  └── 标志寄存器: FLAGS (CF, ZF, SF, OF, PF)                │
├─────────────────────────────────────────────────────────────┤
│  状态机 (7 状态)                                            │
│  ├── FETCH    - 取指令                                      │
│  ├── EXECUTE  - 执行指令                                    │
│  ├── MEMREAD  - 内存读取                                    │
│  ├── MEMWRITE - 内存写入                                    │
│  ├── PUSH     - 压栈操作                                    │
│  ├── POP      - 出栈操作                                    │
│  └── HALT     - 停机                                        │
├─────────────────────────────────────────────────────────────┤
│  指令解码器 (45 条指令)                                     │
│  ├── 数据传送 (5条)                                         │
│  ├── 算术运算 (17条)                                        │
│  ├── 逻辑运算 (5条)                                         │
│  ├── 控制转移 (7条)                                         │
│  ├── 栈操作 (8条)                                           │
│  ├── 子程序调用 (2条)                                       │
│  └── 处理器控制 (2条)                                       │
├─────────────────────────────────────────────────────────────┤
│  执行单元                                                    │
│  ├── ALU (算术逻辑单元)                                     │
│  ├── 标志位更新逻辑                                         │
│  ├── 条件检查逻辑                                           │
│  └── 寄存器选择器                                           │
├─────────────────────────────────────────────────────────────┤
│  内存接口                                                    │
│  ├── 20位地址总线                                           │
│  ├── 16位数据总线                                           │
│  ├── 读写控制信号                                           │
│  └── 段地址计算                                             │
└─────────────────────────────────────────────────────────────┘
```

## 模块化设计

### 核心模块

#### 1. 寄存器文件 (Register File)
```scala
// 所有寄存器的集中管理
class RegisterFile {
  val ax, bx, cx, dx: UInt(16.W)
  val sp, bp, si, di: UInt(16.W)
  val cs, ds, ss, es: UInt(16.W)
  val ip, flags: UInt(16.W)
}
```

#### 2. ALU (算术逻辑单元)
```scala
class ALU {
  def add(a, b): (result, carry, overflow)
  def sub(a, b): (result, carry, overflow)
  def and(a, b): result
  def or(a, b): result
  def xor(a, b): result
  def not(a): result
}
```

#### 3. 控制单元 (Control Unit)
```scala
class ControlUnit {
  val state: FSM(7 states)
  def decode(instruction): signals
  def checkCondition(flags, cond): Bool
}
```

#### 4. 内存接口 (Memory Interface)
```scala
class MemoryInterface {
  val addr: UInt(20.W)
  val dataIn, dataOut: UInt(16.W)
  val read, write: Bool
}
```

## 文件组织建议

### 当前状态
```
src/main/scala/cpu8086/
├── CPU8086.scala          # v0.1.0 (3条指令) - 可删除
├── MyCPU8086_MVP.scala    # v0.2.0 (15条指令) - 可删除
├── MyCPU8086_M2.scala     # v0.3.0 (45条指令) - 保留
└── Main.scala             # Verilog 生成器
```

### 推荐整合后
```
src/main/scala/cpu8086/
├── MyCPU8086.scala        # 统一的 CPU 实现 (基于 M2)
├── Components.scala       # 可复用组件 (ALU, RegisterFile等)
├── Instructions.scala     # 指令定义和解码
└── Main.scala             # Verilog 生成器
```

## 整合步骤

### 步骤 1: 重命名 M2 为主实现
```bash
# 将 M2 作为主要实现
mv MyCPU8086_M2.scala MyCPU8086.scala
```

### 步骤 2: 归档旧版本
```bash
# 移动旧版本到 archive 目录
mkdir -p archive
mv CPU8086.scala archive/CPU8086_v0.1.0.scala
mv MyCPU8086_MVP.scala archive/MyCPU8086_v0.2.0.scala
```

### 步骤 3: 更新类名
```scala
// 在新的 MyCPU8086.scala 中
class MyCPU8086_M2 extends Module {
  // 改为
class MyCPU8086 extends Module {
```

### 步骤 4: 更新测试和文档
- 更新所有测试引用
- 更新 Main.scala
- 更新文档

## 优势分析

### 单一芯片架构的优势

1. **维护简单**
   - 只需维护一个代码库
   - 减少重复代码
   - 统一的 bug 修复

2. **资源优化**
   - 共享硬件资源
   - 减少综合面积
   - 降低功耗

3. **测试效率**
   - 统一的测试框架
   - 完整的功能覆盖
   - 减少测试重复

4. **文档清晰**
   - 单一的架构文档
   - 清晰的版本历史
   - 易于理解

### 保留多版本的场景

**仅在以下情况保留多个版本**:
1. 教学目的 - 展示渐进式开发
2. 性能对比 - 比较不同实现
3. 资源受限 - 需要精简版本
4. 兼容性测试 - 验证向后兼容

## 结论

**推荐方案**: 
- 使用 **MyCPU8086_M2** 作为统一的芯片实现
- 归档旧版本用于参考
- 这是**一个芯片**的最终实现，而不是三个独立芯片

**下一步**:
1. 重命名 M2 为主实现
2. 归档旧版本
3. 更新所有引用
4. 创建 v0.3.0 release

---

**文档版本**: 1.0  
**最后更新**: 2025-11-25  
**作者**: MyCPU8086 开发团队
